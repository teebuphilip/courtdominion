#!/usr/bin/env python3
"""
Generate matchup adjustment multipliers from 30 years of NBA game logs.

Feature 3: Performance multipliers based on opponent defensive strength
and home/road location.

Produces:
    static_data/matchups/matchup_adjustments.py

Usage:
    python -m data_collection.generate_matchup_adjustments
"""

from pathlib import Path
from typing import Dict, Tuple

import pandas as pd

from data_collection.utils import (
    STATIC_DATA_DIR,
    age_bucket,
    load_all_seasons,
    rebucket_role,
)

MIN_SAMPLE_SIZE = 30

MULTIPLIER_STATS = [
    "points",
    "rebounds",
    "assists",
    "steals",
    "blocks",
    "three_pm",
    "fantasy_points",
]

ADJUSTMENT_FIELDS = [
    "points_multiplier",
    "rebounds_multiplier",
    "assists_multiplier",
    "steals_multiplier",
    "blocks_multiplier",
    "three_pm_multiplier",
    "fantasy_pts_multiplier",
    "sample_size",
]


def compute_season_roles(df: pd.DataFrame) -> pd.DataFrame:
    """Compute season-average minutes per player-season, then re-bucket role."""
    season_avg = (
        df.groupby(["player_id", "season_start_year"])["minutes_played"]
        .mean()
        .reset_index()
        .rename(columns={"minutes_played": "season_avg_minutes"})
    )
    season_avg["rebucketed_role"] = season_avg["season_avg_minutes"].apply(rebucket_role)

    return df.merge(
        season_avg[["player_id", "season_start_year", "rebucketed_role"]],
        on=["player_id", "season_start_year"],
        how="left",
    )


def bucket_defense(rank: float) -> str:
    """Map opponent defensive rank (1-30) to tier bucket."""
    if rank <= 6:
        return "Elite"
    if rank <= 12:
        return "Above Avg"
    if rank <= 18:
        return "Average"
    if rank <= 24:
        return "Below Avg"
    return "Poor"


def build_matchup_adjustments(
    df: pd.DataFrame,
    min_sample: int = MIN_SAMPLE_SIZE,
) -> Dict[Tuple[str, str, str, str, str], dict]:
    """
    Build matchup multipliers by (age_bucket, position, role, opponent_bucket, location).

    Multiplier = context_avg / baseline_avg for each stat.
    """
    base_cols = ["age_bucket", "position_group", "rebucketed_role"]
    context_cols = base_cols + ["opponent_bucket", "home_or_road"]

    # Compute baseline averages (across all matchups/locations)
    baseline = df.groupby(base_cols)[MULTIPLIER_STATS].mean()

    # Compute context averages
    context = df.groupby(context_cols)[MULTIPLIER_STATS].mean()
    context_counts = df.groupby(context_cols).size()

    profiles = {}
    for idx in context.index:
        n = int(context_counts[idx])
        if n < min_sample:
            continue

        bucket, pos, role, opp_bucket, location = idx
        base_key = (bucket, pos, role)

        if base_key not in baseline.index:
            continue

        base_avgs = baseline.loc[base_key]
        ctx_avgs = context.loc[idx]

        entry = {}
        for stat in MULTIPLIER_STATS:
            base_val = base_avgs[stat]
            ctx_val = ctx_avgs[stat]
            field_name = f"{stat}_multiplier" if stat != "fantasy_points" else "fantasy_pts_multiplier"
            if base_val > 0:
                entry[field_name] = round(float(ctx_val / base_val), 4)
            else:
                entry[field_name] = None
        entry["sample_size"] = n

        profiles[(bucket, pos, role, opp_bucket, location)] = entry

    return profiles


def write_adjustments_file(
    profiles: dict,
    variable_name: str,
    output_path: Path,
) -> None:
    """Write matchup adjustments dict as a Python literal to a .py file."""
    lines = []
    lines.append("# auto-generated by generate_matchup_adjustments.py")
    lines.append("# Do not edit manually â€” re-run the generator to update.")
    lines.append("")
    lines.append(f"{variable_name} = {{")

    for key in sorted(profiles.keys()):
        entry = profiles[key]
        bucket, pos, role, opp_bucket, location = key
        lines.append(
            f"    ('{bucket}', '{pos}', '{role}', '{opp_bucket}', '{location}'): {{"
        )

        for field in ADJUSTMENT_FIELDS:
            val = entry.get(field)
            if val is None:
                lines.append(f"        '{field}': None,")
            else:
                lines.append(f"        '{field}': {val},")

        lines.append("    },")

    lines.append("}")
    lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines))


def main() -> None:
    """Generate matchup adjustment multipliers."""
    print("Loading all seasons...")
    df = load_all_seasons()
    print(f"  Loaded {len(df):,} rows")

    # Standard cleanup
    before = len(df)
    df = df.dropna(subset=["age"])
    df["age"] = df["age"].astype(int)
    print(f"  Dropped {before - len(df):,} rows with null age ({len(df):,} remaining)")

    before = len(df)
    df = df.dropna(subset=["position_group"])
    print(
        f"  Dropped {before - len(df):,} rows with unknown position "
        f"({len(df):,} remaining)"
    )

    before = len(df)
    df = df[df["minutes_played"] > 0]
    print(
        f"  Dropped {before - len(df):,} rows with 0 minutes "
        f"({len(df):,} remaining)"
    )

    # Drop rows with null opponent defense rank
    before = len(df)
    df = df.dropna(subset=["opponent_def_rank_vs_position"])
    print(
        f"  Dropped {before - len(df):,} rows with null opponent rank "
        f"({len(df):,} remaining)"
    )

    # Compute season-average roles and age buckets
    print("Computing season-average roles...")
    df = compute_season_roles(df)
    df["age_bucket"] = df["age"].apply(age_bucket)
    df = df.dropna(subset=["age_bucket"])

    # Bucket opponent defense
    print("Bucketing opponent defense...")
    df["opponent_bucket"] = df["opponent_def_rank_vs_position"].apply(bucket_defense)

    # Calculate fantasy points
    df["fantasy_points"] = (
        df["points"] * 1.0
        + df["rebounds"] * 1.2
        + df["assists"] * 1.5
        + df["steals"] * 3.0
        + df["blocks"] * 3.0
        + df["turnovers"] * -1.0
    )

    # Show distribution
    for bucket in ["Elite", "Above Avg", "Average", "Below Avg", "Poor"]:
        n = (df["opponent_bucket"] == bucket).sum()
        print(f"  {bucket}: {n:,} games")

    # Build matchup adjustments
    print("Building matchup adjustments...")
    profiles = build_matchup_adjustments(df)
    print(f"  Buckets: {len(profiles)} (after min sample filter)")

    # Write output
    output_path = STATIC_DATA_DIR / "matchups" / "matchup_adjustments.py"
    write_adjustments_file(profiles, "MATCHUP_ADJUSTMENTS", output_path)
    print(f"  Written: {output_path}")

    print("\nDone.")


if __name__ == "__main__":
    main()
