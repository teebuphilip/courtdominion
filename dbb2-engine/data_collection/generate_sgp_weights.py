#!/usr/bin/env python3
"""
Generate SGP (Standings Gain Points) weights from 30 years of NBA game logs.

Feature 13: Category importance weights + positional rarity bonuses
for auction pricing.

Produces:
    static_data/pricing/sgp_weights.py

Usage:
    python -m data_collection.generate_sgp_weights
"""

from pathlib import Path
from typing import Dict

import pandas as pd

from data_collection.utils import (
    STATIC_DATA_DIR,
    load_all_seasons,
    rebucket_role,
)

QUALITY_ROLES = {"Starter", "Rotation"}

# Fantasy-relevant stat categories for SGP
SGP_STATS = ["points", "rebounds", "assists", "steals", "blocks", "three_pm"]

BONUS_THRESHOLD = 1.05  # only store bonuses above this
BONUS_CAP = 2.0


def compute_season_roles(df: pd.DataFrame) -> pd.DataFrame:
    """Compute season-average minutes per player-season, then re-bucket role."""
    season_avg = (
        df.groupby(["player_id", "season_start_year"])["minutes_played"]
        .mean()
        .reset_index()
        .rename(columns={"minutes_played": "season_avg_minutes"})
    )
    season_avg["rebucketed_role"] = season_avg["season_avg_minutes"].apply(rebucket_role)

    return df.merge(
        season_avg[["player_id", "season_start_year", "rebucketed_role"]],
        on=["player_id", "season_start_year"],
        how="left",
    )


def compute_category_weights(player_seasons: pd.DataFrame) -> Dict[str, float]:
    """
    Compute category weights based on coefficient of variation.

    Stats with tighter distributions (lower CV) get higher weights.
    Normalized so points = 1.0.
    """
    # Compute per-season CVs, then average across seasons
    season_cvs = {}
    for season, season_df in player_seasons.groupby("season_start_year"):
        for stat in SGP_STATS:
            mean_val = season_df[stat].mean()
            std_val = season_df[stat].std(ddof=1)
            if mean_val > 0:
                cv = std_val / mean_val
            else:
                cv = None
            season_cvs.setdefault(stat, []).append(cv)

    # Average CV across seasons
    avg_cvs = {}
    for stat in SGP_STATS:
        valid = [v for v in season_cvs[stat] if v is not None]
        avg_cvs[stat] = sum(valid) / len(valid)

    # Normalize: weight = stat_CV / points_CV
    # Higher CV = wider individual spread = scarcer to acquire = more valuable
    points_cv = avg_cvs["points"]
    weights = {}
    for stat in SGP_STATS:
        weights[stat] = round(avg_cvs[stat] / points_cv, 4)

    return weights


def compute_position_bonuses(
    player_seasons: pd.DataFrame,
) -> Dict[tuple, float]:
    """
    Compute positional rarity bonuses.

    For each (stat, position): bonus = overall_avg / position_avg.
    Higher bonus means the stat is rarer from that position (more valuable).
    Only returns bonuses > BONUS_THRESHOLD.
    """
    # Overall averages per stat
    overall_avgs = {}
    for stat in SGP_STATS:
        overall_avgs[stat] = player_seasons[stat].mean()

    # Per-position averages
    pos_avgs = player_seasons.groupby("position_group")[SGP_STATS].mean()

    bonuses = {}
    for pos in pos_avgs.index:
        for stat in SGP_STATS:
            pos_mean = pos_avgs.loc[pos, stat]
            if pos_mean > 0:
                bonus = overall_avgs[stat] / pos_mean
                bonus = min(bonus, BONUS_CAP)
                if bonus > BONUS_THRESHOLD:
                    bonuses[(stat, pos)] = round(bonus, 4)

    return bonuses


def write_sgp_file(
    category_weights: dict,
    position_bonuses: dict,
    seasons_analyzed: int,
    variable_name: str,
    output_path: Path,
) -> None:
    """Write SGP weights as a Python literal to a .py file."""
    lines = []
    lines.append("# auto-generated by generate_sgp_weights.py")
    lines.append("# Do not edit manually â€” re-run the generator to update.")
    lines.append("")
    lines.append(f"{variable_name} = {{")

    # Category weights
    lines.append("    'category_weights': {")
    for stat in sorted(category_weights.keys()):
        lines.append(f"        '{stat}': {category_weights[stat]},")
    lines.append("    },")

    # Position bonuses
    lines.append("    'position_bonuses': {")
    for key in sorted(position_bonuses.keys()):
        stat, pos = key
        lines.append(f"        ('{stat}', '{pos}'): {position_bonuses[key]},")
    lines.append("    },")

    # Seasons analyzed
    lines.append(f"    'seasons_analyzed': {seasons_analyzed},")

    lines.append("}")
    lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines))


def main() -> None:
    """Generate SGP weights."""
    print("Loading all seasons...")
    df = load_all_seasons()
    print(f"  Loaded {len(df):,} rows")

    # Standard cleanup
    before = len(df)
    df = df.dropna(subset=["age"])
    df["age"] = df["age"].astype(int)
    print(f"  Dropped {before - len(df):,} rows with null age ({len(df):,} remaining)")

    before = len(df)
    df = df.dropna(subset=["position_group"])
    print(
        f"  Dropped {before - len(df):,} rows with unknown position "
        f"({len(df):,} remaining)"
    )

    before = len(df)
    df = df[df["minutes_played"] > 0]
    print(
        f"  Dropped {before - len(df):,} rows with 0 minutes "
        f"({len(df):,} remaining)"
    )

    # Compute season-average roles
    print("Computing season-average roles...")
    df = compute_season_roles(df)

    # Filter to fantasy-relevant pool
    quality = df[df["rebucketed_role"].isin(QUALITY_ROLES)]
    print(f"  Fantasy-relevant pool (Starter+Rotation): {len(quality):,} games")

    # Aggregate to player-season averages
    print("Aggregating to player-season averages...")
    player_seasons = (
        quality.groupby(["player_id", "season_start_year"])
        .agg(
            position_group=("position_group", lambda x: x.mode().iloc[0]),
            **{stat: (stat, "mean") for stat in SGP_STATS},
        )
        .reset_index()
    )
    print(f"  Player-seasons: {len(player_seasons):,}")

    seasons = sorted(quality["season_start_year"].unique())

    # Compute category weights
    print("Computing category weights...")
    weights = compute_category_weights(player_seasons)
    for stat, w in sorted(weights.items()):
        print(f"  {stat}: {w}")

    # Compute positional rarity bonuses
    print("Computing positional rarity bonuses...")
    bonuses = compute_position_bonuses(player_seasons)
    for (stat, pos), b in sorted(bonuses.items()):
        print(f"  ({stat}, {pos}): {b}")

    # Write output
    output_path = STATIC_DATA_DIR / "pricing" / "sgp_weights.py"
    write_sgp_file(weights, bonuses, len(seasons), "SGP_WEIGHTS", output_path)
    print(f"  Written: {output_path}")

    print("\nDone.")


if __name__ == "__main__":
    main()
