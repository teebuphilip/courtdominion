#!/usr/bin/env python3
"""
Generate position scarcity multipliers from 30 years of NBA game logs.

Feature 14: Adjustment factor based on supply of quality players per position.

Produces:
    static_data/pricing/position_scarcity.py

Usage:
    python -m data_collection.generate_position_scarcity
"""

from pathlib import Path
from typing import Dict

import pandas as pd

from data_collection.utils import (
    STATIC_DATA_DIR,
    load_all_seasons,
    rebucket_role,
)

SCARCITY_FIELDS = [
    "scarcity_multiplier",
    "avg_quality_players",
    "avg_elite_players",
    "avg_total_players",
    "seasons_analyzed",
]

QUALITY_ROLES = {"Starter", "Rotation"}
ELITE_CUTOFF = 10

# Standard fantasy lineup slots per position (G absorbs PG+SG, F absorbs SF+PF)
DEMAND_WEIGHTS = {"C": 1, "F": 2, "G": 2}


def compute_season_roles(df: pd.DataFrame) -> pd.DataFrame:
    """Compute season-average minutes per player-season, then re-bucket role."""
    season_avg = (
        df.groupby(["player_id", "season_start_year"])["minutes_played"]
        .mean()
        .reset_index()
        .rename(columns={"minutes_played": "season_avg_minutes"})
    )
    season_avg["rebucketed_role"] = season_avg["season_avg_minutes"].apply(rebucket_role)

    return df.merge(
        season_avg[["player_id", "season_start_year", "rebucketed_role"]],
        on=["player_id", "season_start_year"],
        how="left",
    )


def compute_player_season_fantasy(df: pd.DataFrame) -> pd.DataFrame:
    """
    Aggregate to player-season level with fantasy PPG and position.
    """
    df["fantasy_points"] = (
        df["points"] * 1.0
        + df["rebounds"] * 1.2
        + df["assists"] * 1.5
        + df["steals"] * 3.0
        + df["blocks"] * 3.0
        + df["turnovers"] * -1.0
    )

    player_seasons = (
        df.groupby(["player_id", "season_start_year"])
        .agg(
            position_group=("position_group", lambda x: x.mode().iloc[0]),
            rebucketed_role=("rebucketed_role", lambda x: x.iloc[0]),
            avg_fantasy_ppg=("fantasy_points", "mean"),
        )
        .reset_index()
    )

    return player_seasons


def compute_scarcity_by_position(
    player_seasons: pd.DataFrame,
    elite_cutoff: int = ELITE_CUTOFF,
) -> Dict[str, dict]:
    """
    For each position, compute avg quality/elite/total player counts
    across all seasons, then derive scarcity multiplier.
    """
    positions = sorted(player_seasons["position_group"].unique())
    seasons = sorted(player_seasons["season_start_year"].unique())

    season_pos_stats = []
    for season in seasons:
        season_df = player_seasons[player_seasons["season_start_year"] == season]
        for pos in positions:
            pos_df = season_df[season_df["position_group"] == pos]
            total = len(pos_df)
            quality_df = pos_df[pos_df["rebucketed_role"].isin(QUALITY_ROLES)]
            quality = len(quality_df)

            # Elite: top N by fantasy PPG among quality players
            top_n = quality_df.nlargest(elite_cutoff, "avg_fantasy_ppg")
            elite = len(top_n)

            season_pos_stats.append({
                "season": season,
                "position": pos,
                "quality_count": quality,
                "elite_count": elite,
                "total_count": total,
            })

    stats_df = pd.DataFrame(season_pos_stats)

    # Average across seasons per position
    pos_avgs = stats_df.groupby("position").agg(
        avg_quality_players=("quality_count", "mean"),
        avg_elite_players=("elite_count", "mean"),
        avg_total_players=("total_count", "mean"),
    ).to_dict("index")

    # Demand-weighted scarcity: divide quality count by fantasy lineup slots
    # G/F absorb 2 traditional positions each (PG+SG, SF+PF), C is 1
    supply_per_slot = {}
    for pos in pos_avgs:
        demand = DEMAND_WEIGHTS.get(pos, 1)
        supply_per_slot[pos] = pos_avgs[pos]["avg_quality_players"] / demand

    global_avg_supply = sum(supply_per_slot.values()) / len(supply_per_slot)

    # Build output
    scarcity = {}
    for pos in sorted(pos_avgs.keys()):
        vals = pos_avgs[pos]
        scarcity[pos] = {
            "scarcity_multiplier": round(global_avg_supply / supply_per_slot[pos], 4),
            "avg_quality_players": round(vals["avg_quality_players"], 1),
            "avg_elite_players": round(vals["avg_elite_players"], 1),
            "avg_total_players": round(vals["avg_total_players"], 1),
            "seasons_analyzed": len(seasons),
        }

    return scarcity


def write_scarcity_file(
    scarcity: dict,
    variable_name: str,
    output_path: Path,
) -> None:
    """Write position scarcity dict as a Python literal to a .py file."""
    lines = []
    lines.append("# auto-generated by generate_position_scarcity.py")
    lines.append("# Do not edit manually â€” re-run the generator to update.")
    lines.append("")
    lines.append(f"{variable_name} = {{")

    for pos in sorted(scarcity.keys()):
        entry = scarcity[pos]
        lines.append(f"    '{pos}': {{")
        for field in SCARCITY_FIELDS:
            lines.append(f"        '{field}': {entry[field]},")
        lines.append("    },")

    lines.append("}")
    lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines))


def main() -> None:
    """Generate position scarcity multipliers."""
    print("Loading all seasons...")
    df = load_all_seasons()
    print(f"  Loaded {len(df):,} rows")

    # Standard cleanup
    before = len(df)
    df = df.dropna(subset=["age"])
    df["age"] = df["age"].astype(int)
    print(f"  Dropped {before - len(df):,} rows with null age ({len(df):,} remaining)")

    before = len(df)
    df = df.dropna(subset=["position_group"])
    print(
        f"  Dropped {before - len(df):,} rows with unknown position "
        f"({len(df):,} remaining)"
    )

    before = len(df)
    df = df[df["minutes_played"] > 0]
    print(
        f"  Dropped {before - len(df):,} rows with 0 minutes "
        f"({len(df):,} remaining)"
    )

    # Compute season-average roles
    print("Computing season-average roles...")
    df = compute_season_roles(df)

    # Aggregate to player-season level with fantasy points
    print("Computing player-season fantasy averages...")
    player_seasons = compute_player_season_fantasy(df)
    print(f"  Player-seasons: {len(player_seasons):,}")

    # Compute scarcity
    print("Computing position scarcity...")
    scarcity = compute_scarcity_by_position(player_seasons)

    for pos, vals in sorted(scarcity.items()):
        print(
            f"  {pos}: multiplier={vals['scarcity_multiplier']}, "
            f"quality={vals['avg_quality_players']}, "
            f"elite={vals['avg_elite_players']}"
        )

    # Write output
    output_path = STATIC_DATA_DIR / "pricing" / "position_scarcity.py"
    write_scarcity_file(scarcity, "POSITION_SCARCITY", output_path)
    print(f"  Written: {output_path}")

    print("\nDone.")


if __name__ == "__main__":
    main()
